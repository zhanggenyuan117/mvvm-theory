<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>

<body>
    <div id="app">
        <h2>{{message}}</h2>
        <h2>{{message}}</h2>
        <h2>{{message}}</h2>
        <button>按钮</button>
    </div>

    <script>
        document.getElementsByTagName("button")[0].onclick = function () {
            app.message = '抄我代码的人  ,  你好啊 ! '
        };



        class Observe {
            constructor(data) {
                this.data = data;
                //对data对象进行遍历
                Object.keys(data).forEach(key => {
                    this.defineProperty(data, key, data[key])
                })
            }

            defineProperty(data, key, val) {

                const dep = new Dep();

                //判断data是否是对象   如果不是对象  跳出函数
                if (!data || typeof data !== 'object') {
                    return
                }
                Object.defineProperty(data, key, {
                    set(newVal) {
                        console.log('数据改变了')
                        val = newVal;
                        dep.notify();
                    },
                    get() {
                        if (Dep.target) {
                            dep.addSub(Dep.target)
                        }
                        return val
                    }
                })
            }
        }



        class Dep {
            constructor() {
                this.subs = [];
            }
            addSub(sub) {
                this.subs.push(sub)
            }
            notify() {
                this.subs.forEach(sub => {
                    sub.update();
                })
            }
        }



        class Watcher {
            constructor(node, name, vm) {
                this.node = node;
                this.name = name;
                this.vm = vm;
                Dep.target = this;
                this.update();
                Dep.target = null;
            }

            update() {
                // 也找到使用 v-model的message的地方
                this.node.nodeValue = this.vm[this.name]; //一取属性值 就会调用get方法
                this.node.innerHTML = this.vm[this.name];
                this.FindUsev_model(this.vm[this.name]);
            }
            FindUsev_model(value) {
                // 子结点集
                let nodelist = document.querySelector(this.vm.$el).childNodes;
                nodelist.forEach((node) => {
                    if (node.nodeType === 1) {
                        const attrs = node.attributes;
                        // 如果这个结点包含 v-model
                        if (attrs.hasOwnProperty("v-model")) {
                            const newname = attrs["v-model"].nodeValue; //获取这个属性的设置
                            // 并且name与传过来的name相等
                            if (newname == this.name) {
                                node.value = value;
                            }
                        }
                    }
                });
            }
        }

        const reg = /{{(.+)}}/;

        class Compiler {
            //el vm 是Vue构造器里调用的时候传过来的el(#app) vm(Vue里的this)
            constructor(el, vm) {
                // 获取结点 保存数据
                this.el = document.querySelector(el);
                this.vm = vm;
                //这个frag是因为下面 while(child = this.el.firstChild) 这里对结点取出来遍历并解析的时候会删除掉结点，所以解析后要保存起来全部加回来

                this.frag = this._createFragment();

                this.el.appendChild(this.frag);
            }
            _createFragment() {
                const frag = document.createDocumentFragment();
                let child;

                while ((child = this.el.firstChild)) {
                    //在这里对每个结点进行解析 移步 _compile(node)	
                    this._compile(child);
                    frag.appendChild(child);
                }
                return frag;
            }
            _compile(node) {
                if (node.nodeType === 1) {//如果是标签结点
                    //判断是否有v-model属性
                    // 属性结点
                    const attrs = node.attributes;
                    if (attrs.hasOwnProperty("v-model")) {
                        const name = attrs["v-model"].nodeValue; //获取这个属性的值
                        //将这个值赋值给有这个属性的结点 并且在使用到v-model属性的节点上加上时间监听，改变属性的值
                        node.value = this.vm[name];
                        node.addEventListener("input", (e) => {
                            this.vm[name] = e.target.value;
                        });
                    }
                    // 这一段操作是为了简单解决<h1>{{message}}</h1> 这种标签结点里使用{{message}}的
                    //如果这个标签内有使用到{{meesage}}这种形式的 生成对应的wather来管理	
                    let inner = node.innerHTML;
                    if (reg.test(inner)) {
                        // 拿到小括号里的东西 $1
                        const name = RegExp.$1.trim(); //去除空格
                        // name就是变量名了
                        //生成wather的时候呢 调用一次update进行数据的初始化
                        //并且在update里面 this.vm[this.name];这一操作，出发了get 并在get里面将这个Watcher添加到Dep的管理之下 (dep.addSub())
                        new Watcher(node, name, this.vm);
                    }

                }
                if (node.nodeType === 3) {//如果是文本结点 和一段操作一样
                    //文本结点
                    // 正则匹配 {{}}
                    if (reg.test(node.nodeValue)) {
                        // 拿到小括号里的东西 $1
                        const name = RegExp.$1.trim(); //去除空格
                        // name就是变量名了
                        new Watcher(node, name, this.vm);
                    }
                }
            }
        }


        class Vue {
            constructor(options) {
                // 1.保存数据
                this.$options = options;
                this.$data = options.data;
                this.$el = options.el;

                // 2.将data添加进响应式系统里面 数据劫持添加set get
                new Observe(this.$data);

                // 3.代理this.$data的数据
                Object.keys(this.$data).forEach((key) => {
                    this._proxy(key);
                });

                // 4.处理解析el
                new Compiler(this.$el, this);
            }
            _proxy(key) {
                Object.defineProperty(this, key, {
                    configurable: true,
                    enumerable: true,
                    set(newValue) {
                        this.$data[key] = newValue;
                    },
                    get() {
                        return this.$data[key];
                    },
                });
            }
        }

        const app = new Vue({
            el: "#app",
            data: {
                message: 'hello'
            }
        })
    </script>
</body>

</html>